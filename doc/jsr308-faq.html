<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <title>Type annotations FAQ</title>
</head>
<body>

<h1>Type annotations FAQ</h1>

<p>
These are some common questions about the <a href="./">Type Annotations
(JSR 308)</a> extension to Java.  Feel free to
<a href="./#Community">suggest</a> improvements to the answers, or other
questions to include here.
</p>

<p>
Before you read this FAQ, you should probably read either the
<a href="specification/java-annotation-design.html">Type Annotations
Specification</a> (if you are most interested in the language syntax) or
the
<a href="current/checkers-manual.html">Checker Framework Manual</a>
(if you are most interested in pluggable type-checking).  Then, if you
still have questions, you can see whether this FAQ answers them.
</p>

<!--
  Most answers should be short and should point people at the specification,
  so that we don't have to maintain two versions of an explanation.  This FAQ
  is useful for people who like to read them and in some sense it serves as
  an index into the specification, especially for things that don't have an
  obvious and easy-to-find place in the specification.
-->

<p>Contents:</p>
<!-- start toc.  do not edit; run html-update-toc instead -->
    <ul>
      <li><a href="#use">Usability of type annotations</a>
        <ul>
          <li><a href="#usefulness">What are type annotations good for?</a></li>
          <li><a href="#ease-of-use">Are type annotations easy to read and write?</a></li>
          <li><a href="#clutter">Will my code become cluttered with type annotations?</a></li>
        </ul></li>
      <li><a href="#pluggable-types">Pluggable type-checking</a>
        <ul>
          <li><a href="#absolute-guarantee">Can a pluggable type-checker give an absolute guarantee of correctness?</a></li>
          <li><a href="#qualifiers-vs-classes">When should I use type qualifiers, and when should I use subclasses?</a></li>
          <li><a href="#write-checker">How do I create a new checker?</a></li>
          <li><a href="#bug-detector">Why not just use a bug detector like FindBugs?</a></li>
          <li><a href="#jml">How does pluggable type-checking compare with JML?</a></li>
        </ul></li>
      <li><a href="#tools">Tool support</a>
        <ul>
          <li><a href="#inclusion-in-java">Are type annotations part of the Java language?</a></li>
          <li><a href="#backward-compatibility">Can I use type annotations even though my coworkers/boss/users don't use type annotations or Java 7?</a></li>
          <li><a href="#platforms">Do the Type Annotations tools run on Windows?  MacOS?  Linux?</a></li>
          <li><a href="#eclipse">Does Eclipse support type annotations?</a></li>
          <li><a href="#idea">Does IntelliJ IDEA support type annotations?</a></li>
          <li><a href="#bug-reporting">How do I file a bug report?</a></li>
        </ul></li>
      <li><a href="#syntax">Syntax of type annotations</a>
        <ul>
          <li><a href="#return-type">Does an annotation before a method refer to the return type or to the method?</a></li>
          <li><a href="#array-syntax">I don't like array and receiver annotations.</a></li>
        </ul></li>
      <li><a href="#features">Features in the Type Annotations specification</a>
        <ul>
          <li><a href="#type-of-an-object">How do I determine the annotation on an object?</a></li>
          <li><a href="#jsr305">What is the relationship between JSR 308 and JSR 305?</a></li>
          <li><a href="#checker-framework">What is the relationship between JSR 308 and the Checker Framework?</a></li>
          <li><a href="#statement_annotations">Is there a way to annotate statements?</a></li>
          <li><a href="#feature-x">Should the Type Annotations specification support feature X?</a></li>
          <li><a href="#modifying-the-specification">Is the Type Annotations specification set in stone?</a></li>
          <li><a href="#specific-annotations">Why doesn't the Type Annotations specification define useful annotation types?</a></li>
        </ul></li>
      <li><a href="#misc">Miscellaneous</a>
        <ul>
          <li><a href="#jsr">What does &ldquo;JSR&rdquo; mean?</a></li>
        </ul></li>
    </ul>
<!-- end toc -->


<h2 id="use">Usability of type annotations</h2>


<h3 id="usefulness">What are type annotations good for?</h3>

<p>
Type annotations make Java's annotation system more expressive and uniform.
Thus, they can be used for many of the same purposes as Java 5 annotations.
A new use is as type qualifiers.  Programmers can write these type
qualifiers in their programs, and then a compiler plug-in automatically
finds bugs.
</p>

<p>
No tool will solve all your problems, but pluggable type-checkers have been
shown to help programmers to rid their programs of certain important
classes of bugs, including null pointer errors, incorrect side effects,
incorrect equality tests, and more.
Users of the Checker Framework keep noticing new ways that pluggable
type-checkers are useful, and you probably will too.
</p>

<p>
For more details, see the
<a href="current/checkers-manual.html">Checker Framework Manual</a> and
also section
<a href="specification/java-annotation-design.html#type-qualifiers">Example
use of type annotations:  Type qualifiers</a> in the Type Annotations
Specification.
</p>


<h3 id="ease-of-use">Are type annotations easy to read and write?</h3>

<p>
The paper
<a href="http://people.csail.mit.edu/mernst/pubs/pluggable-checkers-issta2008-abstract.html">Practical
pluggable types for Java</a> discusses case studies in which programmers
found type annotations to be natural to read and write.  The code
continued to feel like Java, and the type-checking errors were easy to
comprehend and often led to real bugs.
</p>

<p>
You don't have to take our word for it, though.  You can try the
<a href="current/checkers-manual.html">Checker Framework</a> for yourself.
</p>

<p>
The difficulty of adding and verifying annotations depends on your program.
If your program is well-designed and -documented, then skimming the
existing documentation and writing type annotations is extremely easy.
Otherwise, you may find yourself spending a lot of time trying to
understand, reverse-engineer, or fix bugs in your program, and then just a
moment writing a type annotation that describes what you discovered.  This
process inevitably improves your code.  You must decide whether it is a
good use of your time.  For code that is not causing trouble now and is
unlikely to do so in the future (the code is bug-free, and you do not
anticipate changing it or using it in new contexts), then the
effort of writing type annotations for it may not be justified.
</p>


<h3 id="clutter">Will my code become cluttered with type annotations?</h3>

<p>
As with any language feature, it is possible to write ugly code that
over-uses annotations.  However, in normal use, very few annotations need
to be written.  Figure 1 of the paper
<a href="http://people.csail.mit.edu/mernst/pubs/pluggable-checkers-issta2008-abstract.html">Practical
pluggable types for Java</a> reports data for over 350,000 lines of
type-annotated code:
</p>
<ul>
  <li>
    1 annotation per 62 lines for nullness annotations (<tt>@NonNull</tt>, <tt>@Nullable</tt>, etc.)
    <!-- (/ (+ 4640 3961 10798) (+ 107 35 167)) -->
  </li>
  <li>
    1 annotation per 1736 lines for interning annotations (<tt>@Interned</tt>)
    <!-- (/ 224048 129) -->
  </li>
  <li>
    1 annotation per 27 lines for immutability annotations (IGJ type system)
    <!-- (/ (+ 6236 18159 30507 8691 59221 26828) (+ 315 1125 1386 384 1815 450)) -->
  </li>
</ul>
<p>
Furthermore, these numbers are for annotating existing code.  New code that
is written with the type annotation system in mind is cleaner and more
correct, so it requires even fewer annotations.
</p>

<p>
In other words, annotations do not clutter code, and they are used much
less frequently than generic types, which Java programmers find acceptable.
</p>


<h2 id="pluggable-types">Pluggable type-checking</h2>


<p>
Pluggable type-checking is a motivating application for type annotations.
But a pluggable type-checker is a separate tool that is not specified as
part of Java itself.
</p>


<h3 id="absolute-guarantee">Can a pluggable type-checker give an absolute guarantee of correctness?</h3>

<p>
Each checker looks for certain errors.  You can use multiple checkers, but
even then your program might still contain other kinds of errors.
</p>

<p>
If you run a pluggable checker on only part of the code of a program, then
you do not get a guarantee that all parts of the program satisfy the type
system (that is, are error-free).  An example is a framework that clients
are intended to extend.  In this case, you should recommend that clients
run the pluggable checker.  There is no way to force users to do so, so you
may want to retain dynamic checks or use other mechanisms to detect errors.
</p>

<p>
There are other circumstances in which a static type-checker may fail to
detect a possible type error.  In Java, these include arrays, casts, raw
types, reflection, separate compilation (bytecodes from unverified sources),
native code, etc.  (For details, see section
<a href="http://groups.csail.mit.edu/pag/jsr308/current/checkers-manual.html#checker-guarantees">What
the checker guarantees</a> in the Checker Framework manual.)
Java uses dynamic checks for most of these, so that the
type error cannot cause a security vulnerability or a crash.  The pluggable
type-checkers inherit many (not all) of these weaknesses of Java
type-checking, but do not currently have built-in dynamic checkers.
Writing dynamic checkers would be an interesting and valuable project.
</p>

<!-- This paragraph is weak. -->
<p>
Even if a tool such as a pluggable checker cannot give an ironclad
guarantee of correctness, it is still useful.  It can finding errors, 
excluding certain types of possible problems (e.g., restricting the
possible class of problems), and increasing confidence in a piece of
software.
</p>


<h3 id="qualifiers-vs-classes">When should I use type qualifiers, and when should I use subclasses?</h3>

<p>
In brief, use subtypes when you can, and type qualifiers when you cannot.
For more details, see section 
<a href="http://groups.csail.mit.edu/pag/jsr308/current/checkers-manual.html#when-to-use-type-qualifiers">When to use (and not use) type qualifiers</a> in the Checker Framework manual.
</p>


<h3 id="write-checker">How do I create a new checker?</h3>

<p>
You can use the checkers that are distributed with the Checker Framework,
or you can write your own to check specific properties that you care
about.  Thus, you can find and prevent the bugs that are most important to
you.
</p>

<p>
Section <a href="current/checkers-manual.html#writing-a-checker">How to
create a new checker</a> in the Checker Framework Manual gives
complete details regarding how to write a checker.  It also suggests places
to look for more help, such as the <a href="current/doc/">Checker Framework
API documentation (Javadoc)</a> and the source code of the distributed
checkers.
</p>

<p>
To whet your interest and demonstrate how easy it is to get started, here
is an example of a complete, useful type checker.
</p>

<pre>
  @TypeQualifier
  @SubtypeOf(Unqualified.class)
  public @interface Encrypted { }
</pre>

<p>
Section <a href="current/checkers-manual.html#basic-example">Basic checker
example</a> in the Checker Framework Manual explains this checker and tells
you how to run it.
</p>



<h3 id="bug-detector">Why not just use a bug detector like FindBugs?</h3>

<p>
Pluggable type-checking finds more bugs than a bug detector does, for any
given variety of bug.
</p>

<p>
A bug detector like <a href="http://findbugs.sourceforge.net/">FindBugs</a>,
<a href="http://artho.com/jlint/">JLint</a>, or
<a href="http://pmd.sourceforge.net/">PMD</a> aims to find <em>some</em>
of the most obvious bugs in your program.  It uses a lightweight analysis,
then uses heuristics to discard some of its warnings.  Thus, even if the tool
prints no warnings, your code might still have errors &mdash; maybe the
analysis was too weak to find them, or the tool's heuristics classified the
warnings as likely false positives and discarded them.
</p>

<p>
A type checker aims to find <em>all</em> the bugs (of certain varieties).
It requires you to write type qualifiers in your program, or to use a tool
that infers types.  Thus, it requires more work from the programmer, and in
return it gives stronger guarantees.
</p>

<p>
Each tool is useful in different circumstances, depending on how important 
 the desired
level of confidence in your code.  For more details on the comparison, see
section
<a href="http://groups.csail.mit.edu/pag/jsr308/current/checkers-manual.html#other-tools">Comparison
  to other tools</a> in the Checker Framework manual.
For a case study that compared
the nullness analysis of FindBugs, JLint, PMD, and the Checker Framework,
see section 6 of the paper
<a href="http://www.cs.washington.edu/homes/mernst/pubs/pluggable-checkers-issta2008.pdf">&ldquo;Practical
  pluggable types for Java&rdquo;</a>.
</p>


<h3 id="jml">How does pluggable type-checking compare with JML?</h3>

<p>
<a href="http://www.cs.ucf.edu/~leavens/JML/">JML</a>, the Java Modeling
Language, is a language for writing formal specifications.  JML aims to be
more expressive than pluggable type-checking.  JML is not as practical as
pluggable type-checking.
</p>

<p>
A programmer can write a JML specification that
describes arbitrary facts about program behavior.  Then, the programmer can
use formal reasoning or a theorem-proving tool to verify that the code
meets the specification.  Run-time checking is also possible.
By contrast, pluggable type-checking can express a more limited set of
properties about your program.
</p>

<p>
The JML toolset is less mature.  For instance, if your code uses
generics or other features of Java 5, then you cannot use JML.  
However, JML has a run-time checker, which the Checker Framework currently
lacks.
</p>


<h2 id="tools">Tool support</h2>


<h3 id="inclusion-in-java">Are type annotations part of the Java language?</h3>

<p>
Type annotations will be a part of the Java 7 language.
</p>

<p>
As of build b64 (publicly released on July 9, 2009), Sun's OpenJDK supports
type annotations.  The Type Annotations Compiler is a variant of the
OpenJDK compiler with same extra features for compatibility with non-Java-7
compilers.  It is distributed standalone or as part of the Checker
Framework.
</p>


<h3 id="backward-compatibility">Can I use type annotations even though my coworkers/boss/users don't use type annotations or Java 7?</h3>

<p>
You can use type annotations and custom type-checkers even if your
coworkers and users do not use custom type-checkers or the Type Annotations
compiler.  You simply write the annotations in comments and use the Type
Annotations compiler, which recognizes comments containing type
annotations.  Other developers can compile the annotated code using any
Java compiler, which will ignore the type annotations.  The Type
Annotations compiler produces bytecodes that are identical to those
produced by javac, so the <tt>.class</tt> files can be used in any JVM.
This also gives you an easy way to convince your colleagues to try type
annotations and the Checker Framework.
For more details, see section
<a href="current/checkers-manual.html#annotations-in-comments">Writing
annotations in comments for backward compatibility</a> in the Checker
Framework Manual.
</p>


<h3 id="platforms">Do the Type Annotations tools run on Windows?  MacOS?  Linux?</h3>

<p>
We have had successful reports from users of all three platforms.  If you
have trouble installing or running the tools, please report a bug.  The
<a href="./#Community">Community</a> section of the <a href="./">Type
Annotations webpage</a> explains how.
</p>


<h3 id="eclipse">Does Eclipse support type annotations?</h3>

<p>
Full Type Annotation support is not yet available for the Eclipse compiler.
However, prototype support is available.  See the
<a href="current/checkers-manual.html#eclipse">Eclipse</a> section of the
Checker Framework Manual for details.
</p>


<h3 id="idea">Does IntelliJ IDEA support type annotations?</h3>

<p>
Preliminary support (green parsing of type annotations) is planned for the 
summer 2009 EAP (Early Access Programs) builds of the IDEA 9.
</p>


<h3 id="bug-reporting">How do I file a bug report?</h3>

<p>
See the <a href="./#Community">Community</a> section of the <a href="./">Type
Annotations webpage</a>.
</p>


<h2 id="syntax">Syntax of type annotations</h2>


<h3 id="return-type">Does an annotation before a method refer to the return type or to the method?</h3>

<p>
An annotation before a method sometimes refers to the return type, and
sometimes to the method itself.  There is never any ambiguity regarding
which is intended.  See section <a
href="specification/java-annotation-design.html#disambiguating">Disambiguating
type and declaration annotations</a> in the Type Annotations specification.
</p>

<h3 id="array-syntax">I don't like array and receiver annotations.</h3>

<p>
If you are skeptical of the <em>usefulness</em> of the annotations, see
section <a
href="specification/java-annotation-design.html#type-annotation-use-cases">Uses
for annotations on types</a> in the Type Annotations specification.
</p>

<p>
If you are skeptical of the <em>syntax</em> of array annotations, then
perhaps you really don't like Java's array syntax.  The annotation
extension is a logical extension of Java's syntax; see section <a
href="specification/java-annotation-design.html#array-syntax">Syntax of
array annotations</a> in the Type Annotations specification.
</p>

<p>    
If you are skeptical of the <em>syntax</em> of receiver annotations, then
see section <a
href="specification/java-annotation-design.html#receivers">Receivers</a> in
the Type Annotations specification.
</p>

<p>
While these annotations are critical in important circumstances, they are
not extremely common in well-written code.  And
<em>you</em> don't have to use them if you don't want to.
</p>


<h2 id="features">Features in the Type Annotations specification</h2>


<h3 id="type-of-an-object">How do I determine the annotation on an object?</h3>

<p>
Objects are not annotated &mdash; types or declarations are.
Java has no run-time representation of the types of the variables that
refer to an object.  The Type Annotations specification (JSR 308) enriches
types, but it does not change that fundamental property.  Type annotations
as implemented in JSR 308 have no run-time representation.  This means that
they impose no run-time burden on Java programs that use them.
</p>

<p>
Reflective calls can query the class of an object, or can query the type
annotations on source code.
</p>


<h3 id="jsr305">What is the relationship between JSR 308 and JSR 305?</h3>

<p>
Type Annotations (JSR 308) is a language extension that makes existing and
future annotations more useful to programmers.  By contrast, Annotations
for Software Defect Detection (JSR 305) defines some specific annotations,
such as <tt>@Nonnull</tt> and <tt>@Positive</tt>.  The JSR 305 annotations
are most useful if they can be written on types, so JSR 305 needs JSR 308
to achieve its full potential.  For a more detailed comparison, see section
<a href="specification/java-annotation-design.html#semantics">Semantics of
annotations</a> in the Type Annotations specification.
</p>


<!--
 Perhaps discuss other tools:  JastAdd, JavaCOP, etc.  The problem is
 that none of them scales, and thus none of them is of practical use at
 present.  But I don't really want to trash them in this document, for
 political reasons.
-->


<h3 id="checker-framework">What is the relationship between JSR 308 and the Checker Framework?</h3>

<p>
The Type Annotations (JSR 308) language extension permits you to write
annotations in new locations.  This syntax makes possible new sorts of
tools, such as pluggable type-checking.  The
<a href="current/checkers-manual.html">Checker Framework</a> enables you to
create and use pluggable type-checkers.
</p>

<p>
Implementing pluggable type-checking would be impractical without the Type
Annotations syntax, but the Checker Framework is an independent tool and
not a part of the Type Annotations proposal.  The Checker Framework
distribution includes the Type Annotations compiler for convenience, so
that users only have to download and install one file.
</p>


<h3 id="statement_annotations">Is there a way to annotate statements?</h3>

<p>
Statement annotations are within the scope of JSR 308, and this feature is
under consideration.  See the section <a
href="specification/java-annotation-design.html#statement-annotations">Annotations on Statements</a> in the Type Annotations specification.
</p>

<h3 id="feature-x">Should the Type Annotations specification support feature X?</h3>

<p>
Perhaps it should.  See section <a
href="specification/java-annotation-design.html#other-annotations">Other
possible extensions to Java annotations</a> in the Type Annotations
Specification.  Feel free to suggest modifications or additions to that
section.  Your edits should correct factual errors, or should be
well-motivated by compelling use-cases that cannot be achieved by other
means.
</p>

<h3 id="modifying-the-specification">Is the Type Annotations specification set in stone?</h3>

<p>
The Type Annotations (JSR 308) expert group gladly welcomes suggestions for improvements to
the Type Annotations specification, and to the tools that support it.  See
section <a
href="specification/java-annotation-design.html#other-annotations">Other
possible extensions to Java annotations</a> in the Type Annotations
Specification.
</p>


<h3 id="specific-annotations">Why doesn't the Type Annotations specification define useful annotation types?</h3>

<p>
Defining annotations is beyond the scope of the Type Annotations
Specification, whose purpose is to lay the groundwork so that others can
define such types.
</p>


<h2 id="misc">Miscellaneous</h2>

<h3 id="jsr">What does &ldquo;JSR&rdquo; mean?</h3>

<p>
A JSR, or Java Specification Request, is a proposed specification for some
aspect of the Java platform &mdash; the Java language, virtual machine,
libraries, etc.  For more details, see the
<a href="http://jcp.org/en/introduction/faq">Java Community Process
FAQ</a>.  Many people refer to the Type Annotations specification by its
Sun codename, &ldquo;JSR 308&rdquo;.
</p>



<hr />

<p>
Last updated: June 28, 2009.
</p>

<p>
Back to the <a href="./">Type annotations (JSR 308) webpage</a>.
</p>

</body>
</html>
<!--
Local Variables:
time-stamp-start: "^Last updated: "
time-stamp-end: "\\.?$"
time-stamp-format: "%:b %:d, %:y"
time-stamp-line-limit: -50
End:
-->


<!--  LocalWords:  MacOS nullness NonNull Nullable IGJ bytecodes webpage javac
 -->
<!--  LocalWords:  codename Nonnull IntelliJ EAP TypeQualifier SubtypeOf JLint
 -->
<!--  LocalWords:  FindBugs PMD toolset standalone
 -->
